<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        body{font-family: "Helvetica Neue", serif;}

        .highlighted{
            background-color: lawngreen;   margin:0; border:none;
            padding:0;
        }

        #text-input{margin-right:20px;}
        label{margin-right:5px;}

    </style>
</head>
<body>
<div>
    <label id="search-input-label">Search for </label>
    <input id="text-input" type="text" oninput="showMatches()"
           onchange="showMatches()">
    <input type="checkbox" id="case-sensitive-checkbox"
           onchange="showMatches()">
    <label id="case-sensitive-label">Case-Sensitive </label>
    <p id="result-line">
        Matches found: <span id="search-result"></span>
    </p>

</div>

<p id="text-to-search">I live at 100 N. 7000 W. West Valley City, UT. My zip code is 90210-1012. The ongoing public feud between Sen. Bob Corker and President Donald Trump exploded Tuesday ahead of the President's high-stakes visit to Capitol Hill for tax negotiations, with the Tennessee Republican telling CNN's Manu Raju he wouldn't support Trump for president if given the opportunity again.
</p>
<br>
<br>
<br>
<pre id="debug-text"></pre>


<script src="jquery-3.2.1.min.js"></script>
<script>

    function showMatches(){
        var userInput = $('#text-input').val();

        if (userInput === '' ){
            clearMatches();
        }
        else{
            updateMatches(userInput);
        }
    }


    function clearMatches(){
        var paragraph = $('#text-to-search');
        paragraph.children('span').removeClass('highlighted');
        $('#search-result').text('0');
    }


    function updateMatches(userInput){

        var matches = getMatches(userInput);

        if (empty(matches)){
            clearMatches();
        }
        else {
            setMatchesFoundNumber(matches);
            highlightMatches(matches);
        }
    }


    function setMatchesFoundNumber(matches){
        $('#search-result').text(matches.length);
    }


    function getMatches(userInput){

        var pattern = prepRegularExpression(userInput);

        var searchText = $('#text-to-search').text();

        return searchText.match(pattern);
    }


    function prepRegularExpression(userInput){
        userInput = escapeSpecialCharsForRegexUse(userInput);

        var caseModifier = getCaseModifier();

        return new RegExp(userInput, (caseModifier + 'g'));
    }


    function escapeSpecialCharsForRegexUse(txt){

        // To ignore the meaning of escaped special characters inside regex patterns,
        // Another 2 backslashes have to be added to their beginning, even
        // though they're already escaped:
        var escapedSpecialChars = [
            "\\\\", "\\\$", "\\\^", "\\\*", "\\\(", "\\\)", "\\\?",
            "\\\+", "\\\[", "\\\|", "\\\.", "\\\/"
        ];

        for (var i=0;  i < escapedSpecialChars.length;  ++i){
            txt = txt.replace(new RegExp(escapedSpecialChars[i],'g'),
                escapedSpecialChars[i]);
        }

        return txt;
    }


    function getCaseModifier(){
        var caseModifier = 'i';
        var caseSensitive = $('#case-sensitive-checkbox').prop('checked');
        if (caseSensitive) { caseModifier = ''; }
        return caseModifier;
    }


    /*
     Important Issue:
       Neither the 'innerHTML' or 'innerText' properties contain the exact
       same text that is displayed in the browser page.  For display, the
       browser removes any extra spaces so there is always just one space
       separating words and sentences.  But when you retrieve the value of
       'innerText', you get the text precisely as it's written in the HTML
       file: excessive spaces, tabs, line breaks, everything.
       This has caused unexpected behavior during testing of this
        app.  The solution is to either format the inner text
       in the file the same way as it's shown in the browser, or, wrap the
       text inside a <pre> element so that what you see is what you get.
       If you want the user to be able to modify the text that will
       eventually be searched, you should choose the latter.  Else, choose
       the former.  Of course this only applies to text-search matching
       applications.

        Other Issues:
            Converting innerHTML to innerText via a statement like:
            $('p').text( $('p').html() );
        will cause any special characters (such as '<' and '>' used in tags)
        to be displayed as HTML character entities ( such as '&lt;' and '&gt;' )
    */

    function empty(matches){
        //for debugging:
       // $('#debug-text').text(innerText);
        return isNotArray(matches);
    }


    function isNotArray(param){
        return ( !Array.isArray(param) );
    }


    function highlightMatches(matches){

        var paragraph = $('#text-to-search');

        // Without this line you'll get redundant loop iterations:
        matches = uniqueItems(matches);

        var innerText =  wrapEachInsideSpanElement(matches);

        paragraph.html(innerText);

        paragraph.children('span').addClass('highlighted');

    }


    function wrapEachInsideSpanElement(matches){
        const OPENSPAN = '⚣⚣⚣';
        const CLOSESPAN = '⚤⚤⚤';

        for (var i=0, innerText = $('#text-to-search').text();
             i < matches.length;   ++i){
            var unescapedSearch = matches[i];
            var escapedSearch = escapeSpecialCharsForRegexUse(unescapedSearch);
            var regex = new RegExp(escapedSearch,'g');
            innerText = innerText.replace(regex,
                OPENSPAN + unescapedSearch + CLOSESPAN);
            // <span> substitutions.  Substituting html tags with
            // these special placeholders and then putting the tags
            // back in once the loop is over solves bugs.
        }

        regex = new RegExp(OPENSPAN,'g');
        innerText = innerText.replace(regex, "<span>");
        regex = new RegExp(CLOSESPAN,'g');
        innerText = innerText.replace(regex, "</span>");

        return innerText;
    }


    function uniqueItems(arr){
        for (var i=0, newArr=[];  i<arr.length;  ++i){
            if (i===0) {
                newArr.push(arr[i]);
            }
            else if (newArr.indexOf( arr[i] ) === -1) {
                newArr.push(arr[i]);
            }
        }
        return newArr;
    }

</script>
</body>
</html>